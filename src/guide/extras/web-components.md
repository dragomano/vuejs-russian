# Vue и веб-компоненты {#vue-and-web-components}

[Веб-компоненты](https://developer.mozilla.org/en-US/docs/Web/Web_Components) это общий термин для набора нативных веб-интерфейсов, позволяющих разработчикам создавать многократно используемые пользовательские элементы.

Мы считаем Vue и веб-компоненты в первую очередь взаимодополняющими технологиями. Vue отлично поддерживает как потребление, так и создание пользовательских элементов. Вне зависимости от того, интегрируете ли вы пользовательские элементы в существующее приложение Vue или используете Vue для создания и распространения пользовательских элементов, вы находитесь в хорошей компании.

## Использование пользовательских элементов в Vue {#using-custom-elements-in-vue}

Vue [набирает 100% в тестах Custom Elements Everywhere](https://custom-elements-everywhere.com/libraries/vue/results/results.html). Потребление пользовательских элементов в приложении Vue в основном работает так же, как и использование нативных HTML-элементов, но есть несколько моментов, о которых следует помнить:

### Пропуск разрешения компонентов {#skipping-component-resolution}

По умолчанию Vue будет пытаться разрешить неродной HTML-тег как зарегистрированный компонент Vue, прежде чем вернуться к его отрисовке как пользовательского элемента. Это приведёт к тому, что Vue выдаст предупреждение «failed to resolve component» во время разработки. Чтобы сообщить Vue, что определённые элементы должны рассматриваться как пользовательские и пропускать разрешение компонентов, мы можем указать свойство [`compilerOptions.isCustomElement`](/api/application#app-config-compileroptions).

Если вы используете Vue с настройками сборки, опция должна передаваться через конфигурацию сборки, поскольку это опция времени компиляции.

#### Пример конфигурации в браузере {#example-in-browser-config}

```js
// Работает только при использовании компиляции в браузере.
// Если вы используете инструменты сборки, смотрите примеры конфигурации ниже.
app.config.compilerOptions.isCustomElement = (tag) => tag.includes('-')
```

#### Пример конфигурации Vite {#example-vite-config}

```js
// vite.config.js
import vue from '@vitejs/plugin-vue'

export default {
  plugins: [
    vue({
      template: {
        compilerOptions: {
          // воспринимайте все теги с тире как пользовательские элементы
          isCustomElement: (tag) => tag.includes('-')
        }
      }
    })
  ]
}
```

#### Пример конфигурации Vue CLI {#example-vue-cli-config}

```js
// vue.config.js
module.exports = {
  chainWebpack: (config) => {
    config.module
      .rule('vue')
      .use('vue-loader')
      .tap((options) => ({
        ...options,
        compilerOptions: {
          // Рассматривайте все теги, начинающиеся с ion-, как пользовательские элементы
          isCustomElement: (tag) => tag.startsWith('ion-')
        }
      }))
  }
}
```

### Передача свойств DOM {#passing-dom-properties}

Поскольку атрибуты DOM могут быть только строками, нам нужно передавать сложные данные в пользовательские элементы как свойства DOM. При установке параметров для пользовательского элемента Vue 3 автоматически проверяет наличие DOM-свойства с помощью оператора `in` и предпочитает устанавливать значение как DOM-свойство, если ключ присутствует. Это означает, что в большинстве случаев вам не придется думать об этом, если пользовательский элемент соответствует [рекомендуемым лучшим практикам](https://web.dev/custom-elements-best-practices/).

Однако могут быть редкие случаи, когда данные должны быть переданы как свойство DOM, но пользовательский элемент не определяет/отражает свойство должным образом (что приводит к неудачной проверке `in`). В этом случае вы можете заставить привязку `v-bind` быть установленной в качестве свойства DOM с помощью модификатора `.prop`:

```vue-html
<my-element :user.prop="{ name: 'jack' }"></my-element>

<!-- сокращённый эквивалент -->
<my-element .user="{ name: 'jack' }"></my-element>
```

## Создание пользовательских элементов с помощью Vue {#building-custom-elements-with-vue}

Главное преимущество пользовательских элементов в том, что их можно использовать с любым фреймворком или даже без него. Это делает их идеальными для распространения компонентов, где конечный потребитель может не использовать тот же стек фронтендов, или когда вы хотите изолировать конечное приложение от деталей реализации компонентов, которые оно использует.

### defineCustomElement {#definecustomelement}

Vue поддерживает создание пользовательских элементов, используя точно такие же API компонентов Vue, с помощью метода [`defineCustomElement`](/api/general#definecustomelement). Метод принимает тот же аргумент, что и [`defineComponent`](/api/general#definecomponent), но вместо него возвращает пользовательский конструктор элемента, который расширяет `HTMLElement`:

```vue-html
<my-vue-element></my-vue-element>
```

```js
import { defineCustomElement } from 'vue'

const MyVueElement = defineCustomElement({
  // обычные опции компонентов Vue здесь
  props: {},
  emits: {},
  template: `...`,

  // только defineCustomElement: CSS будет внедрен в теневой корень
  styles: [`/* встроенный CSS */`]
})

// Регистрируем пользовательский элемент.
// После регистрации все теги `<my-vue-element>`
// на странице будут обновлены.
customElements.define('my-vue-element', MyVueElement)

// Вы также можете программно создать элемент:
// (можно сделать только после регистрации)
document.body.appendChild(
  new MyVueElement({
    // начальные параметры (необязательно)
  })
)
```

#### Жизненный цикл {#lifecycle}

- Пользовательский элемент Vue монтирует внутренний экземпляр компонента Vue внутри своего теневого корня при первом вызове [`connectedCallback`](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks) элемента.

- Когда вызывается `disconnectedCallback` элемента, Vue проверяет, отсоединен ли элемент от документа после тика микрозадачи.

  - Если элемент всё ещё находится в документе, это перемещение, и экземпляр компонента будет сохранен;

  - Если элемент отсоединяется от документа, это будет удаление, и экземпляр компонента будет размонтирован.

#### Входные параметры {#props}

- Все параметры, объявленные с помощью свойства `props`, будут определены для пользовательского элемента как свойства. Vue автоматически обрабатывает отражение между атрибутами/свойствами, где это необходимо.

  - Атрибуты всегда отражаются в соответствующих свойствах.

  - Свойства с примитивными значениями (`строка`, `булево` или `число`) отражаются как атрибуты.

- Vue также автоматически приводит параметры, объявленные с типами `Boolean` или `Number`, к нужному типу, когда они устанавливаются в качестве атрибутов (которые всегда являются строками). Например, приведённое ниже объявление параметра:

  ```js
  props: {
    selected: Boolean,
    index: Number
  }
  ```

  И использование пользовательских элементов:

  ```vue-html
  <my-element selected index="1"></my-element>
  ```

  В компоненте `selected` будет приведен к `true` (булевому значению), а `index` будет приведен к `1` (числу).

#### События {#events}

События, вызванные через `this.$emit` или setup `emit`, отправляются как собственные [CustomEvents](https://developer.mozilla.org/en-US/docs/Web/Events/Creating_and_triggering_events#adding_custom_data_%E2%80%93_customevent) на пользовательский элемент. Дополнительные аргументы события (полезная нагрузка) будут отображаться в виде массива на объекте CustomEvent в качестве его свойства `detail`.

#### Слоты {#slots}

Внутри компонента слоты могут быть отображены с помощью элемента `<slot/>`, как обычно. Однако при потреблении результирующего элемента он принимает только [синтаксис родных слотов](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_templates_and_slots):

- [Слоты с ограниченной областью действия](/guide/components/slots#scoped-slots) не поддерживаются.

- При передаче именованных слотов используйте атрибут `slot` вместо директивы `v-slot`:

  ```vue-html
  <my-element>
    <div slot="named">привет</div>
  </my-element>
  ```

#### Provide / Inject {#provide-inject}

API [Provide / Inject](/guide/components/provide-inject#provide-inject) и его эквивалент [Composition API](/api/composition-api-dependency-injection#provide) также работают между пользовательскими элементами, определяемыми Vue. Однако обратите внимание, что это работает **только между пользовательскими элементами**, т. е. пользовательский элемент, определённый Vue, не сможет внедрить свойства, предоставляемые компонентом Vue, не являющимся пользовательским элементом.

### SFC как пользовательский элемент {#sfc-as-custom-element}

`defineCustomElement` также работает с однофайловыми компонентами Vue (SFC). Однако при стандартной настройке инструментария `<style>` внутри SFC все равно будут извлечены и объединены в один CSS-файл во время сборки. При использовании SFC в качестве пользовательского элемента часто желательно внедрить теги `<style>` в теневой корень пользовательского элемента.

Официальные инструменты SFC поддерживают импорт SFC в «режиме пользовательского элемента» (требуется `@vitejs/plugin-vue@^1.4.0` или `vue-loader@^16.5.0`). SFC, загруженный в режиме пользовательского элемента, вставляет свои теги `<style>` в виде строк CSS и раскрывает их в опции компонента `styles`. Это будет подхвачено `defineCustomElement` и вставлено в теневой корень элемента при его инстанцировании.

Чтобы перейти в этот режим, просто завершите имя файла компонента символом `.ce.vue`:

```js
import { defineCustomElement } from 'vue'
import Example from './Example.ce.vue'

console.log(Example.styles) // ["/* встроенный CSS */"]

// преобразовываем в конструктор пользовательского элемента
const ExampleElement = defineCustomElement(Example)

// регистрируем
customElements.define('my-example', ExampleElement)
```

Если вы хотите настроить, какие файлы должны быть импортированы в режиме пользовательских элементов (например, рассматривать _все_ SFC как пользовательские элементы), вы можете передать свойство `customElement` соответствующим плагинам сборки:

- [@vitejs/plugin-vue](https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#using-vue-sfcs-as-custom-elements)
- [vue-loader](https://github.com/vuejs/vue-loader/tree/next#v16-only-options)

### Советы по созданию библиотеки пользовательских элементов Vue {#tips-for-a-vue-custom-elements-library}

При создании пользовательских элементов с помощью Vue, элементы будут полагаться на время выполнения Vue. В зависимости от того, сколько функций используется, базовый размер составляет ~16 Кб. Это означает, что не стоит использовать Vue, если вы отправляете один пользовательский элемент — возможно, вам стоит использовать ванильный JavaScript, [petite-vue](https://github.com/vuejs/petite-vue) или фреймворки, которые специализируются на небольших размерах во время выполнения. Однако базовый размер более чем оправдан, если вы поставляете коллекцию пользовательских элементов со сложной логикой, поскольку Vue позволяет создавать каждый компонент с гораздо меньшим количеством кода. Чем больше элементов вы транспортируете вместе, тем лучше компромисс.

Если пользовательские элементы будут использоваться в приложении, которое также использует Vue, вы можете выбрать внешнее внедрение Vue из собранного пакета, чтобы элементы использовали ту же копию Vue, что и в хост-приложении.

Рекомендуется экспортировать отдельные конструкторы элементов, чтобы ваши пользователи могли импортировать их по требованию и регистрировать их с нужными именами тегов. Вы также можете экспортировать удобную функцию для автоматической регистрации всех элементов. Вот пример точки входа в библиотеку пользовательских элементов Vue:

```js
import { defineCustomElement } from 'vue'
import Foo from './MyFoo.ce.vue'
import Bar from './MyBar.ce.vue'

const MyFoo = defineCustomElement(Foo)
const MyBar = defineCustomElement(Bar)

// экспортируем отдельные элементы
export { MyFoo, MyBar }

export function register() {
  customElements.define('my-foo', MyFoo)
  customElements.define('my-bar', MyBar)
}
```

Если у вас много компонентов, вы также можете использовать такие функции инструментов сборки, как [glob import](https://vitejs.dev/guide/features.html#glob-import) от Vite или [`require.context`](https://webpack.js.org/guides/dependency-management/#requirecontext) от webpack для загрузки всех компонентов из каталога.

### Веб-компоненты и Typescript {#web-components-and-typescript}

Если вы разрабатываете приложение или библиотеку, вам может понадобиться [проверка типов](/guide/scaling-up/tooling.html#typescript) ваших компонентов Vue, включая те, которые определены как пользовательские элементы.

Пользовательские элементы регистрируются глобально с помощью собственных API, поэтому по умолчанию они не будут иметь определения типа при использовании в шаблонах Vue. Чтобы обеспечить поддержку типов для компонентов Vue, зарегистрированных как пользовательские элементы, мы можем зарегистрировать глобальные типы компонентов с помощью интерфейса [`GlobalComponents`](https://github.com/vuejs/language-tools/blob/master/packages/vscode-vue/README.md#usage) в шаблонах Vue и/или в [JSX](https://www.typescriptlang.org/docs/handbook/jsx.html#intrinsic-elements):

```typescript
import { defineCustomElement } from 'vue'

// vue SFC
import CounterSFC from './src/components/counter.ce.vue'

// превращаем компоненты в веб-компоненты
export const Counter = defineCustomElement(CounterSFC)

// регистрируем глобальные типы
declare module 'vue' {
  export interface GlobalComponents {
    Counter: typeof Counter
  }
}
```

## Веб-компоненты и компоненты Vue {#web-components-vs-vue-components}

Некоторые разработчики считают, что следует избегать проприетарных моделей компонентов, и что использование только пользовательских элементов делает приложение «защищенным от будущего». Здесь мы попытаемся объяснить, почему мы считаем, что это слишком упрощённый взгляд на проблему.

Между пользовательскими компонентами и компонентами Vue действительно есть определённый уровень совпадения функций: и те, и другие позволяют нам определять многократно используемые компоненты с передачей данных, эмуляцией событий и управлением жизненным циклом. Однако API веб-компонентов относительно низкоуровневые и «голые». Чтобы создать реальное приложение, нам нужно довольно много дополнительных возможностей, которые платформа не охватывает:

- Декларативная и эффективная система шаблонов;

- Реактивная система управления состоянием, облегчающая извлечение и повторное использование межкомпонентной логики;

- Производительный способ рендеринга компонентов на сервере и их гидратации на клиенте (SSR), что важно для SEO и [показателей Web Vitals, таких как LCP](https://web.dev/vitals/). Нативные пользовательские элементы SSR обычно включают в себя имитацию DOM в Node.js и последующую сериализацию изменённого DOM, в то время как Vue SSR компилируется в конкатенацию строк, когда это возможно, что гораздо более эффективно.

Компонентная модель Vue разработана с учётом этих потребностей как целостная система.

При наличии компетентной команды инженеров вы, вероятно, сможете создать эквивалент поверх родных пользовательских элементов — но это также означает, что вы берете на себя долгосрочное бремя поддержки собственного фреймворка, теряя при этом преимущества экосистемы и сообщества, присущие таким зрелым фреймворкам, как Vue.

Существуют также фреймворки, использующие пользовательские компоненты в качестве основы своей компонентной модели, но все они неизбежно вынуждены внедрять свои собственные решения перечисленных выше проблем. Использование этих фреймворков подразумевает принятие технических решений по решению этих проблем, что, несмотря на рекламу, автоматически не страхует вас от потенциальных отказов в будущем.

Есть также некоторые области, в которых пользовательские элементы, на наш взгляд, являются ограничивающими:

- Стремление оценить слот мешает составлению компонентов. [Слоты с ограниченной областью действия](/guide/components/slots#scoped-slots) в Vue — это мощный механизм для компоновки компонентов, который не может быть поддержан пользовательскими элементами из-за нетерпеливой природы родных слотов. Нетерпеливые слоты также означают, что принимающий компонент не может контролировать, когда и нужно ли отображать часть содержимого слота.

- Доставка пользовательских элементов с теневым DOM с помощью CSS сегодня требует встраивания CSS в JavaScript, чтобы они могли быть инжектированы в теневые корни во время выполнения. Они также приводят к дублированию стилей в разметке в сценариях SSR. В этой области ведется работа над [возможностями платформы](https://github.com/whatwg/html/pull/4898/) — но на данный момент они ещё не поддерживаются повсеместно, и ещё предстоит решить проблемы с производительностью и SSR. Между тем, Vue SFC предоставляют [механизмы CSS с ограниченной областью действия](/api/sfc-css-features), которые поддерживают извлечение стилей в обычные CSS-файлы.

Vue всегда будет в курсе последних стандартов веб-платформы, и мы с радостью будем использовать всё, что предоставляет платформа, если это облегчит нашу работу. Однако наша цель — предоставить решения, которые хорошо работают и работают сегодня. Это означает, что мы должны внедрять новые функции платформы с критическим подходом — и это предполагает заполнение пробелов, в которых стандарты пока не справляются.
