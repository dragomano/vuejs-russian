# Композитные функции {#composables}

<script setup>
import { useMouse } from './mouse'
const { x, y } = useMouse()
</script>

:::tip
Этот раздел предполагает базовые знания об API Composition. Если вы изучали Vue только с API Options, вы можете переключить стиль API на Composition API (с помощью переключателя в верхней части левой боковой панели) и перечитать главы [Основы реактивности](/guide/essentials/reactivity-fundamentals) и [Хуки жизненного цикла](/guide/essentials/lifecycle).
:::

## Что такое «Composable»? {#what-is-a-composable}

В контексте приложений Vue «composable» («композит») это функция, использующая Composition API для инкапсуляции и повторного использования **логики с отслеживанием состояния**.

При создании фронтенд-приложений нам часто приходится повторно использовать логику для решения общих задач. Например, нам может понадобиться форматировать даты во многих местах, поэтому мы извлекаем для этого многократно используемую функцию. Эта функция форматирования включает в себя **беспорядочную логику**: она принимает некоторые входные данные и сразу же возвращает ожидаемый результат. Существует множество библиотек для повторного использования логики без статических данных — например, [lodash](https://lodash.com/) и [date-fns](https://date-fns.org/), о которых вы, возможно, слышали.

В отличие от этого, логика с состоянием подразумевает управление состоянием, которое меняется с течением времени. Простой пример — отслеживание текущего положения мыши на странице. В реальных сценариях это может быть и более сложная логика, например, сенсорные жесты или статус подключения к базе данных.

## Пример трекера мыши {#mouse-tracker-example}

Если бы мы реализовали функцию отслеживания мыши с помощью Composition API непосредственно внутри компонента, это выглядело бы следующим образом:

```vue
<script setup>
import { ref, onMounted, onUnmounted } from 'vue'

const x = ref(0)
const y = ref(0)

function update(event) {
  x.value = event.pageX
  y.value = event.pageY
}

onMounted(() => window.addEventListener('mousemove', update))
onUnmounted(() => window.removeEventListener('mousemove', update))
</script>

<template>Позиция курсора мыши: {{ x }}, {{ y }}</template>
```

Но что, если мы хотим повторно использовать одну и ту же логику в нескольких компонентах? Мы можем извлечь логику во внешний файл в виде композитной функции:

```js
// mouse.js
import { ref, onMounted, onUnmounted } from 'vue'

// По соглашению, имена композитных функций начинаются с "use"
export function useMouse() {
  // состояние, инкапсулированное и управляемое composable
  const x = ref(0)
  const y = ref(0)

  // composable может обновлять свое управляемое состояние с течением времени.
  function update(event) {
    x.value = event.pageX
    y.value = event.pageY
  }

  // компонент может также подключиться к жизненному хуку
  // компонента-владельца для установки и снятия побочных эффектов.
  onMounted(() => window.addEventListener('mousemove', update))
  onUnmounted(() => window.removeEventListener('mousemove', update))

  // отображаем управляемое состояние в качестве возвращаемого значения
  return { x, y }
}
```

Вот как его можно использовать в компонентах:

```vue
<script setup>
import { useMouse } from './mouse.js'

const { x, y } = useMouse()
</script>

<template>Позиция курсора мыши: {{ x }}, {{ y }}</template>
```

<div class="demo">
  Позиция курсора мыши: {{ x }}, {{ y }}
</div>

[Попробовать в Песочнице](https://play.vuejs.org/#eNqNkj1rwzAQhv/KocUOGKVzSAIdurVjoQUvJj4XlfgkJNmxMfrvPcmJkkKHLrbu69H7SlrEszFyHFDsxN6drDIeHPrBHGtSvdHWwwKDwzfNHwjQWd1DIbd9jOW3K2qq6aTJxb6pgpl7Dnmg3NS0365YBnLgsTfnxiNHACvUaKe80gTKQeN3sDAIQqjignEhIvKYqMRta1acFVrsKtDEQPLYxuU7cV8Msmg2mdTilIa6gU5p27tYWKKq1c3ENphaPrGFW25+yMXsHWFaFlfiiOSvFIBJjs15QJ5JeWmaL/xYS/Mfpc9YYrPxl52ULOpwhIuiVl9k07Yvsf9VOY+EtizSWfR6xKK6itgkvQ/+fyNs6v4XJXIsPwVL+WprCiL8AEUxw5s=)

Как мы видим, основная логика остается идентичной — всё, что нам нужно было сделать, это перенести её во внешнюю функцию и вернуть состояние, которое должно быть открыто. Как и в компоненте, в композитных функциях можно использовать весь набор функций [Composition API](/api/#composition-api). Та же функциональность `useMouse()` теперь может быть использована в любом компоненте.

Самое приятное в композитных функциях то, что их можно вложить друг в друга: Одна композитная функция может вызывать одну или несколько других композитных функций. Это позволяет нам компоновать сложную логику с помощью небольших изолированных блоков, подобно тому, как мы компонуем целое приложение с помощью компонентов. Собственно, именно поэтому мы решили назвать коллекцию API, которые делают этот паттерн возможным, Composition API.

Например, мы можем выделить логику добавления и удаления слушателя событий DOM в отдельный компонент:

```js
// event.js
import { onMounted, onUnmounted } from 'vue'

export function useEventListener(target, event, callback) {
  // Если вы хотите, вы также можете сделать так,
  // чтобы он поддерживал строки селектора в качестве цели
  onMounted(() => target.addEventListener(event, callback))
  onUnmounted(() => target.removeEventListener(event, callback))
}
```

И теперь наша функция `useMouse()` может быть упрощена до:

```js{3,9-12}
// mouse.js
import { ref } from 'vue'
import { useEventListener } from './event'

export function useMouse() {
  const x = ref(0)
  const y = ref(0)

  useEventListener(window, 'mousemove', (event) => {
    x.value = event.pageX
    y.value = event.pageY
  })

  return { x, y }
}
```

:::tip Примечание
Каждый экземпляр компонента, вызывающий `useMouse()`, будет создавать свои собственные копии состояния `x` и `y`, чтобы они не мешали друг другу. Если вы хотите управлять общим состоянием компонентов, прочитайте главу [Управление состоянием](/guide/scaling-up/state-management).
:::

## Пример асинхронного состояния {#async-state-example}

Функция `useMouse()` не принимает никаких аргументов, поэтому давайте рассмотрим другой пример, в котором они используются. При выполнении асинхронной выборки данных нам часто приходится обрабатывать различные состояния: загрузку, успех и ошибку:

```vue
<script setup>
import { ref } from 'vue'

const data = ref(null)
const error = ref(null)

fetch('...')
  .then((res) => res.json())
  .then((json) => (data.value = json))
  .catch((err) => (error.value = err))
</script>

<template>
  <div v-if="error">Упс! Произошла ошибка: {{ error.message }}</div>
  <div v-else-if="data">
    Данные загружены:
    <pre>{{ data }}</pre>
  </div>
  <div v-else>Загрузка...</div>
</template>
```

Было бы утомительно повторять этот шаблон в каждом компоненте, которому нужно получить данные. Давайте извлечем его в виде композитной функции:

```js
// fetch.js
import { ref } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  fetch(url)
    .then((res) => res.json())
    .then((json) => (data.value = json))
    .catch((err) => (error.value = err))

  return { data, error }
}
```

Теперь в нашем компоненте мы можем просто сделать это:

```vue
<script setup>
import { useFetch } from './fetch.js'

const { data, error } = useFetch('...')
</script>
```

### Принятие реактивного состояния {#accepting-reactive-state}

Функция `useFetch()` принимает на вход статическую строку URL — таким образом, она выполняет выборку только один раз и на этом завершается. Что, если мы хотим, чтобы она выполняла повторную выборку при каждом изменении URL? Чтобы добиться этого, нам нужно передать реактивное состояние в композитную функцию, а композитная создать наблюдатели, которые будут выполнять действия, используя переданное состояние.

Например, `useFetch()` должна иметь возможность принимать ссылку:

```js
const url = ref('/initial-url')

const { data, error } = useFetch(url)

// это должно вызвать повторную выборку
url.value = '/new-url'
```

Или функцию-геттер:

```js
// повторная выборка при изменении props.id
const { data, error } = useFetch(() => `/posts/${props.id}`)
```

Мы можем отрефакторить нашу существующую реализацию с помощью API [`watchEffect()`](/api/reactivity-core.html#watcheffect) и [`toValue()`](/api/reactivity-utilities.html#tovalue):

```js{8,13}
// fetch.js
import { ref, watchEffect, toValue } from 'vue'

export function useFetch(url) {
  const data = ref(null)
  const error = ref(null)

  const fetchData = () => {
    // сбрасываем состояние перед получением
    data.value = null
    error.value = null

    fetch(toValue(url))
      .then((res) => res.json())
      .then((json) => (data.value = json))
      .catch((err) => (error.value = err))
  }

  watchEffect(() => {
    fetchData()
  })

  return { data, error }
}
```

`toValue()` — это API, добавленный в версии 3.3. Он предназначен для нормализации ссылок или геттеров в значения. Если аргумент является ссылкой, то возвращается значение ссылки; если аргумент является функцией, он вызовет функцию и вернет её возвращаемое значение. В противном случае он возвращает аргумент как есть. Он работает аналогично [`unref()`](/api/reactivity-utilities.html#unref), но с особым подходом к функциям.

Обратите внимание, что `toValue(url)` вызывается **внутри** обратного вызова `watchEffect`. Это гарантирует, что все реактивные зависимости, к которым обращаются во время нормализации `toValue()`, будут отслежены наблюдателем.

Эта версия `useFetch()` теперь принимает статические строки URL, ссылки и геттеры, что делает её гораздо более гибкой. Эффект watch будет запущен немедленно и будет отслеживать все зависимости, к которым обращались во время `toValue(url)`. Если зависимости не отслеживаются (например, url уже является строкой), эффект выполняется только один раз; в противном случае он будет запускаться заново при каждом изменении отслеживаемой зависимости.

Вот [обновленная версия `useFetch()`](https://play.vuejs.org/#eNp9Vdtu40YM/RVWL1ZQr5RF0JfAMXpLgRZtd5Fu90kvY4mKJ5FnhLnYMQz/+5IcSZF3g30IbPNyyHPIYU7ZL31f7CNmt9nK1073ATyG2K8ro3e9dQFO4LBdQm13fQzYwBlaZ3ewoKTFLCh6/ANDvZ38RTmaiidPkZWprfEBNsrj/66DO1hsQ+j9bVk+eWv6TtW4tV2DrgjHXte2wYKKlsE21pcEkNJ1Q5nUUb54v7gajVHwxhbz/Aru1lOhHymn2KsuIsWPGSdoVFBLQOeso57vJgI5gc0CHQZ3JHfCPFUGJjimQH1dGt6T5VyZVZnUJB3pR8Ad8QtIvwD+tqqB3gqXWzasNjEEa2D/rrXurso0aAM/VRn8XHe6fmYLk9ZVtj6dQMP5vCpTiqBXYdXoPWXrlkKFEEUyMEH36w+29z/AvfBEIhVNQIfNLRCWBBc79F49ouDy4CVx6GlqQXQg3Af+nNWn0JLKp2+pD+w8pmZYY8r5nT6gI9pcdtU7ZB7sSyXp95sYa1ZKm8eiKEb/qpykzJbZbMFofy/39aDIcd+2WIclBPtZ5nO5u5XBF0lpo6mDJrYXO5CGnbZAmk17Z2LH+zF60gJ95eK/WQO58kdTz1cIoCwphZ4a+EBsYIM0e4SWqwvlFMV1p91i+GROc/vWPoe23R4hbFEeRwrlLrbOGht9dwRvQYeFh+BU/UwPW3lQE0CDPZqG9uUIm+MFFyE4sifspOzdqPHwfF674eczcBZk5YJuda1VR0U6dQTqVpmGxpJWl+ULAOqgdICgd2jjUJTNBBANa30FB911/DyjM8KTrANP3SZmim38QIbSlsLcQfukS4oVlA1nM5DI8E77gUAYb4AngqkjmRCTFLZ8KAT9YlApkrJoMa0ZFTtDzTJCjsNqfTtJHCL54yxHCEaGXx0sOTKVeUPPykzrPKmX6g1IBg/wkZ4B6ZDnw6IsyflE051vKC3npwHgYnPp3rWQ/6PCtkiDI+8aroubGS0uJsAjeabPb/oyhEvm3I+cp3zxkBZBfi2uXlMHWZZwc30tVhbnTBcgeJpQqx9FaLoBgl5l/J9Ad+g+9KyDrzK6dsNIM9V19vCX2IKLuBzt9Rbr5zfsT/6FbVX2kd+r22OVTb6g3COG5L7/7198oe+Tc2eb2FH0d5wPLFLkHlPYr9E01PYsTrr9Uy4bnYVP/v4loPEjKW5U5JD4KqO79tt3qL+2e1PcSB6reP4CbzCltA==), с искусственной задержкой и рандомизированной ошибкой для демонстрационных целей.

## Соглашения и лучшие практики {#conventions-and-best-practices}

### Именование {#naming}

Принято называть композитные функции именами в camelCase, которые начинаются с "use".

### Входные аргументы {#input-arguments}

Композитная функция может принимать ссылки или геттеры в качестве аргументов, даже если она не полагается на них для реактивности. Если вы пишете композитную функцию, которая может быть использована другими разработчиками, неплохо бы обработать случай, когда входными аргументами являются ссылки или геттеры, а не необработанные значения. Для этого пригодится функция [`toValue()`](/api/reactivity-utilities#tovalue):

```js
import { toValue } from 'vue'

function useFeature(maybeRefOrGetter) {
  // Если maybeRefOrGetter является ссылкой или геттером,
  // будет возвращено его нормализованное значение.
  // В противном случае она возвращается как есть.
  const value = toValue(maybeRefOrGetter)
}
```

Если ваша функция создает реактивные эффекты, когда на вход подается ссылка или геттер, убедитесь, что вы либо явно следите за ссылкой/геттером с помощью `watch()`, либо вызываете `toValue()` внутри `watchEffect()`, чтобы она была правильно отслежена.

Рассмотренная ранее реализация [useFetch()](#accepting-reactive-state) представляет собой конкретный пример композитной функции, принимающей в качестве входного аргумента реактивные ссылки, геттеры и простые значения.

### Возвращаемые значения {#return-values}

Вы, наверное, заметили, что в композитных функциях мы используем исключительно `ref()`, а не `reactive()`. Рекомендуется, чтобы композитные функции всегда возвращали простой, нереактивный объект, содержащий несколько ссылок. Это позволяет разрушать его на составляющие, сохраняя реакционную способность:

```js
// x и y - ссылки
const { x, y } = useMouse()
```

Возврат реактивного объекта из композитной функции приведёт к тому, что такие деструктуры потеряют связь реактивности с состоянием внутри композита, в то время как рефлексы сохранят эту связь.

Если вы предпочитаете использовать возвращаемое состояние из коимпозитных функций в качестве свойств объекта, вы можете обернуть возвращаемый объект с помощью `reactive()`, чтобы рефлексы были развернуты. Например:

```js
const mouse = reactive(useMouse())
// mouse.x связан с оригинальной ссылкой
console.log(mouse.x)
```

```vue-html
Позиция курсора мыши: {{ mouse.x }}, {{ mouse.y }}
```

### Побочные эффекты {#side-effects}

Можно выполнять побочные действия (например, добавление слушателей событий DOM или получение данных) в составных элементах, но обратите внимание на следующие правила:

- Если вы работаете над приложением, использующим [рендеринг на стороне сервера](/guide/scaling-up/ssr) (SSR), убедитесь, что побочные эффекты, специфичные для DOM, выполняются в хуках жизненного цикла после монтирования, например `onMounted()`. Эти хуки вызываются только в браузере, поэтому вы можете быть уверены, что код в них имеет доступ к DOM.

- Не забудьте убрать побочные эффекты в `onUnmounted()`. Например, если компонент устанавливает слушатель событий DOM, он должен удалить этот слушатель в `onUnmounted()`, как мы видели в примере `useMouse()`. Хорошей идеей может быть использование композитной функции, которая автоматически делает это за вас, как пример `useEventListener()`.

### Ограничения на использование {#usage-restrictions}

Составляющие должны вызываться только в `<script setup>` или в хуке `setup()`. В этих контекстах их также следует вызывать **синхронно**. В некоторых случаях вы также можете вызывать их в хуках жизненного цикла, например `onMounted()`.

Эти ограничения важны, поскольку именно в этих контекстах Vue может определить текущий активный экземпляр компонента. Доступ к активному экземпляру компонента необходим для того, чтобы:

1. В нем можно зарегистрировать хуки жизненного цикла.

2. Вычисляемые свойства и наблюдатели могут быть связаны с ним, чтобы их можно было утилизировать при размонтировании экземпляра для предотвращения утечек памяти.

:::tip Совет
`<script setup>` — единственное место, где вы можете вызывать составные части **после** использования `await`. Компилятор автоматически восстанавливает активный контекст экземпляра после выполнения операции async.
:::

## Извлечение составных частей для организации кода {#extracting-composables-for-code-organization}

Составные части могут быть извлечены не только для повторного использования, но и для организации кода. По мере роста сложности компонентов вы можете столкнуться с тем, что они станут слишком большими для навигации и рассуждений. Composition API предоставляет вам полную гибкость в организации кода компонента в более мелкие функции, основанные на логических соображениях:

```vue
<script setup>
import { useFeatureA } from './featureA.js'
import { useFeatureB } from './featureB.js'
import { useFeatureC } from './featureC.js'

const { foo, bar } = useFeatureA()
const { baz } = useFeatureB(foo)
const { qux } = useFeatureC(baz)
</script>
```

В некоторой степени эти извлечённые составные части можно рассматривать как сервисы с компонентным копированием, которые могут взаимодействовать друг с другом.

## Использование составных элементов в Options API {#using-composables-in-options-api}

Если вы используете Options API, композитные функции должны быть вызваны внутри `setup()`, а возвращаемые привязки должны быть возвращены из `setup()`, чтобы они были доступны `this` и шаблону:

```js
import { useMouse } from './mouse.js'
import { useFetch } from './fetch.js'

export default {
  setup() {
    const { x, y } = useMouse()
    const { data, error } = useFetch('...')
    return { x, y, data, error }
  },
  mounted() {
    // Открытые свойства setup() могут быть доступны через `this`.
    console.log(this.x)
  }
  // ...другие параметры
}
```

## Сравнение с другими методами {#comparisons-with-other-techniques}

### Примеси {#vs-mixins}

Пользователи, пришедшие из Vue 2, могут быть знакомы с опцией [mixins](/api/options-composition#mixins), которая также позволяет нам извлекать логику компонентов в многократно используемые блоки. У примесей есть три основных недостатка:

1. **Нечистый источник свойств**: При использовании большого количества примесей становится неясно, какое свойство экземпляра инжектируется какой примесью, что затрудняет отслеживание реализации и понимание поведения компонента. Именно поэтому мы рекомендуем использовать шаблон «refs + деструктуризация» для композитных функций: это делает источник свойств понятным для потребляющих компонентов.

2. **Коллизии пространств имён**: несколько примесей от разных авторов могут регистрировать одни и те же ключи свойств, что приводит к коллизии пространств имён. С помощью составных переменных можно переименовывать деструктурированные переменные, если в них есть конфликтующие ключи из разных составных переменных.

3. **Неявная кросс-примесевая коммуникация**: Несколько примесей, которые должны взаимодействовать друг с другом, должны полагаться на общие ключи свойств, что делает их неявно связанными. В композитных функциях значения, возвращаемые одной функцией, могут передаваться в другую в качестве аргументов, как и в обычных функциях.

По вышеуказанным причинам мы больше не рекомендуем использовать примеси в Vue 3. Эта функция сохраняется только для миграции и удобства.

### Компоненты без отрисовки {#vs-renderless-components}

В главе о слотах компонентов мы обсудили паттерн [Компонент без отрисовки](/guide/components/slots#renderless-components), основанный на скопированных слотах. Мы даже реализовали демонстрацию отслеживания мыши с помощью компонентов без отрисовки.

Основное преимущество композитных компонентов перед компонентами без отрисовки заключается в том, что композитные компоненты не несут дополнительных накладных расходов на экземпляр компонента. При использовании во всём приложении количество дополнительных экземпляров компонентов, создаваемых шаблоном компонентов без отрисовки, может стать заметным повышением производительности.

Рекомендуется использовать составные компоненты при повторном использовании чистой логики и компоненты при повторном использовании как логики, так и визуальной компоновки.

### Хуки React {#vs-react-hooks}

Если у вас есть опыт работы с React, вы можете заметить, что это очень похоже на пользовательские хуки React. Composition API был частично вдохновлен хуками React, и композиты Vue действительно похожи на хуки React в плане возможностей логической композиции. Однако композитные элементы Vue основаны на мелкозернистой системе реактивности Vue, которая в корне отличается от модели выполнения хуков React. Более подробно это обсуждается в [ЧаВо по Composition API](/guide/extras/composition-api-faq#comparison-with-react-hooks).

## Дальнейшее чтение {#further-reading}

- [Реактивность в деталях](/guide/extras/reactivity-in-depth): чтобы получить представление о том, как работает система реактивности Vue.
- [Управление состоянием](/guide/scaling-up/state-management): для моделей управления состоянием, разделяемым несколькими компонентами.
- [Тестирование композитных функций](/guide/scaling-up/testing#testing-composables): советы по модульному тестированию композитов.
- [VueUse](https://vueuse.org/): постоянно растущая коллекция композитных функций Vue. Исходный код также является отличным учебным ресурсом.
