# Пользовательские директивы {#custom-directives}

<script setup>
const vFocus = {
  mounted: el => {
    el.focus()
  }
}
</script>

## Введение {#introduction}

Помимо стандартного набора директив, поставляемых в ядре (например, `v-model` или `v-show`), Vue также позволяет регистрировать собственные директивы.

Мы представили две формы повторного использования кода в Vue: [компоненты](/guide/essentials/component-basics) и [композиты](./composables). Компоненты являются основными строительными блоками, в то время как композиты сосредоточены на повторном использовании логики, основанной на состоянии. Пользовательские директивы, с другой стороны, в основном предназначены для повторного использования логики, которая включает низкоуровневый доступ к DOM для простых элементов.

Пользовательская директива определяется как объект, содержащий элементы жизненного цикла, аналогичные компоненту. Крючки получают элемент, к которому привязана директива. Вот пример директивы, которая фокусирует ввод, когда элемент вставляется в DOM с помощью Vue:

<div class="composition-api">

```vue
<script setup>
// включает v-focus в шаблонах
const vFocus = {
  mounted: (el) => el.focus()
}
</script>

<template>
  <input v-focus />
</template>
```

</div>

<div class="options-api">

```js
const focus = {
  mounted: (el) => el.focus()
}

export default {
  directives: {
    // включает v-focus в шаблонах
    focus
  }
}
```

```vue-html
<input v-focus />
```

</div>

<div class="demo">
  <input v-focus placeholder="This should be focused" />
</div>

Если предположить, что вы не нажимали на другие кнопки на странице, ввод выше должен быть автофокусированным. Эта директива более полезна, чем атрибут `autofocus`, потому что она работает не только при загрузке страницы — она также работает, когда элемент динамически вставляется Vue.

<div class="composition-api">

В `<script setup>` любая переменная camelCase, начинающаяся с префикса `v`, может быть использована в качестве пользовательской директивы. В приведённом выше примере `vFocus` можно использовать в шаблоне как `v-focus`.

Если не используется `<script setup>`, пользовательские директивы могут быть зарегистрированы с помощью опции `directives`:

```js
export default {
  setup() {
    /*...*/
  },
  directives: {
    // включает v-focus в шаблонах
    focus: {
      /* ... */
    }
  }
}
```

</div>

<div class="options-api">

Как и компоненты, пользовательские директивы должны быть зарегистрированы, чтобы их можно было использовать в шаблонах. В приведённом выше примере мы используем локальную регистрацию с помощью опции `directives`.

</div>

Также часто встречается глобальная регистрация пользовательских директив на уровне приложения:

```js
const app = createApp({})

// делаем v-focus пригодным для использования во всех компонентах
app.directive('focus', {
  /* ... */
})
```

:::tip Совет
Пользовательские директивы следует использовать только в тех случаях, когда требуемая функциональность может быть достигнута только путём прямого манипулирования DOM. Предпочитайте декларативную шаблонизацию с использованием встроенных директив, таких как `v-bind`, когда это возможно, потому что они более эффективны и удобны для серверного рендеринга.
:::

## Хуки директив {#directive-hooks}

Объект определения директивы может предоставлять несколько функций хука (все они необязательны):

```js
const myDirective = {
  // вызывается до применения атрибутов связанного
  // элемента или слушателей событий
  created(el, binding, vnode, prevVnode) {
    // подробнее об аргументах см. ниже
  },
  // вызывается непосредственно перед вставкой элемента в DOM.
  beforeMount(el, binding, vnode, prevVnode) {},
  // вызывается, когда родительский компонент связанного элемента
  // и все его дочерние элементы смонтированы.
  mounted(el, binding, vnode, prevVnode) {},
  // вызывается перед обновлением родительского компонента
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // вызывается после того, как родительский компонент
  // и все его дочерние компоненты обновятся
  updated(el, binding, vnode, prevVnode) {},
  // вызывается перед размонтированием родительского компонента
  beforeUnmount(el, binding, vnode, prevVnode) {},
  // вызывается, когда родительский компонент размонтирован
  unmounted(el, binding, vnode, prevVnode) {}
}
```

### Аргументы хуков {#hook-arguments}

Эти аргументы передаются хукам директив:

- `el`: элемент, к которому привязана директива. Это можно использовать для прямого манипулирования DOM.

- `binding`: объект, содержащий следующие свойства.

  - `value`: Значение, передаваемое директиве. Например, в `v-my-directive="1 + 1"` значение будет `2`.
  - `oldValue`: Предыдущее значение, доступное только в `beforeUpdate` и `updated`. Оно доступно независимо от того, изменилось значение или нет.
  - `arg`: Аргумент, переданный директиве, если таковой имеется. Например, в `v-my-directive:foo` аргументом будет `"foo"`.
  - `modifiers`: Объект, содержащий модификаторы, если таковые имеются. Например, в `v-my-directive.foo.bar` объект модификаторов будет иметь вид `{ foo: true, bar: true }`.
  - `instance`: Экземпляр компонента, в котором используется директива.
  - `dir`: объект определения директивы.

- `vnode`: базовый узел VNode, представляющий связанный элемент.
- `prevNode`: VNode, представляющий связанный элемент из предыдущего рендера. Доступно только в хуках `beforeUpdate` и `updated`.

В качестве примера рассмотрим использование следующей директивы:

```vue-html
<div v-example:foo.bar="baz">
```

Аргумент `binding` будет представлять собой объект в форме:

```js
{
  arg: 'foo',
  modifiers: { bar: true },
  value: /* значение `baz` */,
  oldValue: /* значение `baz` из предыдущего обновления */
}
```

Подобно встроенным директивам, аргументы пользовательских директив могут быть динамическими. Например:

```vue-html
<div v-example:[arg]="value"></div>
```

Здесь аргумент директивы будет реактивно обновляться на основе свойства `arg` в состоянии нашего компонента.

:::tip Примечание
Кроме `el`, вы должны рассматривать эти аргументы как предназначенные только для чтения и никогда не изменять их. Если вам нужно обмениваться информацией между хуками, рекомендуется делать это через [dataset](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/dataset) элемента.
:::

## Директива в виде функции {#function-shorthand}

Обычно пользовательская директива имеет одинаковое поведение для `mounted` и `updated` и не нуждается в других хуках. В таких случаях мы можем определить директиву как функцию:

```vue-html
<div v-color="color"></div>
```

```js
app.directive('color', (el, binding) => {
  // это будет вызвано для `mounted` и `updated`.
  el.style.color = binding.value
})
```

## Литералы объектов {#object-literals}

Если вашей директиве требуется несколько значений, вы также можете передать объектный литерал JavaScript. Помните, что директивы могут принимать любое правильное выражение JavaScript.

```vue-html
<div v-demo="{ color: 'white', text: 'привет!' }"></div>
```

```js
app.directive('demo', (el, binding) => {
  console.log(binding.value.color) // => "white"
  console.log(binding.value.text) // => "привет!"
})
```

## Использование в компонентах {#usage-on-components}

При использовании в компонентах пользовательские директивы всегда будут применяться к корневому узлу компонента, подобно [Обычным атрибутам](/guide/components/attrs).

```vue-html
<MyComponent v-demo="test" />
```

```vue-html
<!-- шаблон MyComponent -->

<div> <!-- Здесь будет применена директива v-demo -->
  <span>Содержание компонента</span>
</div>
```

Обратите внимание, что компоненты потенциально могут иметь более одного корневого узла. При применении к мультикорневому компоненту директива будет проигнорирована, и будет выдано предупреждение. В отличие от атрибутов, директивы не могут быть переданы другому элементу с помощью `v-bind="$attrs"`. В целом, **не** рекомендуется использовать пользовательские директивы в компонентах.
