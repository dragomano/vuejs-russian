# Декларативная отрисовка {#declarative-rendering}

<div class="sfc">

В редакторе вы видите однофайловый компонент Vue (SFC). SFC — это многоразовый автономный блок кода с HTML, CSS и JavaScript, которые принадлежат друг другу и записаны внутри файла `.vue`.

</div>

Основная особенность Vue — **декларативная отрисовка**: используя синтаксис шаблона, который расширяет HTML, мы можем описать, как должен выглядеть HTML на основе состояния JavaScript. При изменении состояния HTML обновляется автоматически.

<div class="composition-api">

Состояние, которое может инициировать обновления при изменении, считается **реактивным**. Мы можем объявить реактивное состояние, используя API Vue `reactive()`. Объекты, созданные с помощью `reactive()`, представляют собой JavaScript-объект [Proxy](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Proxy), которые работают так же, как обычные объекты:

```js
import { reactive } from 'vue'

const counter = reactive({
  count: 0
})

console.log(counter.count) // 0
counter.count++
```

`reactive()` работает только с объектами (включая массивы и встроенные типы, такие как `Map` и `Set`). С другой стороны, `ref()` может принимать любой тип значения и создавать объект, который содержит внутреннее значение в свойстве `.value`:

```js
import { ref } from 'vue'

const message = ref('Привет, мир!')

console.log(message.value) // "Привет, мир!"
message.value = 'Изменено'
```

Подробности о `reactive()` и `ref()` обсуждаются в главе <a target="_blank" href="/guide/essentials/reactivity-fundamentals.html">Основы реактивности</a>.

<div class="sfc">

Реактивное состояние, объявленное в блоке компонента `<script setup>`, может быть использовано непосредственно в шаблоне. Вот как мы можем вывести динамический текст, основанный на значении объекта `counter` и ссылки `message`:

</div>

<div class="html">

Объект, передаваемый в `createApp()`, является компонентом Vue. Состояние компонента должно быть объявлено в его функции `setup()`, а возвращено с помощью объекта:

```js{2,5}
setup() {
  const counter = reactive({ count: 0 })
  const message = ref('Привет, мир!')
  return {
    counter,
    message
  }
}
```

Свойства возвращаемого объекта будут доступны в шаблоне. Вот как мы можем вывести динамический текст, основанный на значении `message`:

</div>

```vue-html
<h1>{{ message }}</h1>
<p>count: {{ counter.count }}</p>
```

Обратите внимание, что нам не нужно использовать `.value` при обращении к ссылке `message` в шаблонах: она автоматически разворачивается для более краткого использования.

</div>

<div class="options-api">

Состояния, которые могут вызывать обновления при изменении, считаются **реактивными**. В Vue реактивное состояние хранится в компонентах. <span class="html">В коде примера объект, передаваемый в `createApp()`, является компонентом.</span>

Мы можем объявить реактивное состояние, используя свойство `data` компонента, которая должна быть функцией, возвращающей объект:

<div class="sfc">

```js{3-5}
export default {
  data() {
    return {
      message: 'Привет, мир!'
    }
  }
}
```

</div>
<div class="html">

```js{3-5}
createApp({
  data() {
    return {
      message: 'Привет, мир!'
    }
  }
})
```

</div>

Свойство `message` будет доступно в шаблоне. Вот как мы можем вывести динамический текст, основанный на значении `message`:

```vue-html
<h1>{{ message }}</h1>
```

</div>

Содержимое внутри усов не ограничивается только идентификаторами или путями — мы можем использовать любое допустимое выражение JavaScript:

```vue-html
<h1>{{ message.split('').reverse().join('') }}</h1>
```

<div class="composition-api">

Теперь попробуйте самостоятельно создать реактивное состояние и использовать его для вывода динамического текстового содержимого для `<h1>` в шаблоне.

</div>

<div class="options-api">

Теперь попробуйте самостоятельно создать свойство `data` и использовать его в качестве текстового содержимого для `<h1>` в шаблоне.

</div>
