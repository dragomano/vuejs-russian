# Глоссарий {#glossary}

Этот глоссарий призван дать некоторые указания относительно значений технических терминов, которые обычно используются при разговоре о Vue. Он предназначен для _описания_ того, как обычно используются термины, а не для _предписания_ того, как они должны использоваться. Некоторые термины могут иметь несколько иное значение или нюансы в зависимости от окружающего контекста.

[[TOC]]

## асинхронный компонент {#async-component}

_Асинхронный компонент_ — это обёртка вокруг другого компонента, позволяющая лениво загружать обёрнутый компонент. Обычно используется для уменьшения размера собранных файлов `.js`, позволяя разбить их на более мелкие фрагменты, которые загружаются только при необходимости.

В Vue Router есть аналогичная функция [ленивой загрузки компонентов маршрута](https://router.vuejs.org/guide/advanced/lazy-loading.html), хотя она не использует функцию асинхронных компонентов Vue.

Узнать больше:

- [Руководство - Асинхронные компоненты](/guide/components/async.html)

## макрос компилятора {#compiler-macro}

_Макрос компилятора_ — это специальный код, который обрабатывается компилятором и преобразуется во что-то другое. По сути, они представляют собой умную форму замены строк.

Компилятор Vue [SFC](#single-file-component) поддерживает различные макросы, такие как `defineProps()`, `defineEmits()` и `defineExpose()`. Эти макросы намеренно разработаны так, чтобы выглядеть как обычные функции JavaScript, чтобы они могли использовать тот же парсер и инструменты вывода типов, что и JavaScript/TypeScript. Однако они не являются реальными функциями, выполняемыми в браузере. Это специальные строки, которые компилятор обнаруживает и заменяет реальным кодом JavaScript, который будет выполняться на самом деле.

Макросы имеют ограничения на использование, которые не распространяются на обычный код JavaScript. Например, вы можете подумать, что `const dp = defineProps` позволит вам создать псевдоним для `defineProps`, но на самом деле это приведёт к ошибке. Существуют также ограничения на то, какие значения можно передавать в `defineProps()`, поскольку «аргументы» должны обрабатываться компилятором, а не во время выполнения.

Узнать больше:

- [`<script setup>` - `defineProps()` и `defineEmits()`](/api/sfc-script-setup.html#defineprops-defineemits)
- [`<script setup>` - `defineExpose()`](/api/sfc-script-setup.html#defineexpose)

## компонент {#component}

Термин _компонент_ не является уникальным для Vue. Он характерен для многих фреймворков пользовательского интерфейса. Он описывает часть пользовательского интерфейса, например кнопку или флажок. Компоненты также можно объединять в более крупные компоненты.

Компоненты — это основной механизм, предоставляемый Vue для разделения пользовательского интерфейса на более мелкие части, как для улучшения сопровождаемости, так и для повторного использования кода.

Компонент Vue — это объект. Все свойства необязательны, но для отрисовки компонента требуется либо шаблон, либо рендер-функция. Например, следующий объект будет действительным компонентом:

```js
const HelloWorldComponent = {
  render() {
    return 'Привет, мир!'
  }
}
```

На практике большинство приложений Vue пишутся с использованием [однофайловых компонентов](#single-file-component) (файлы с расширением `.vue`). Хотя на первый взгляд эти компоненты не могут быть объектами, компилятор SFC преобразует их в объект, который используется в качестве экспорта по умолчанию для файла. С внешней точки зрения, файл `.vue` — это просто модуль ES, экспортирующий объект компонента.

Свойства объекта компонента обычно называются _опциями_. Именно отсюда [Options API](#options-api) получает свое название.

Опции компонента определяют, как должны создаваться экземпляры этого компонента. Компоненты концептуально похожи на классы, хотя Vue не использует для их определения реальные классы JavaScript.

Термин «компонент» также может использоваться в более свободном смысле для обозначения экземпляров компонентов.

Узнать больше:

- [Руководство - Основы компонентов](/guide/essentials/component-basics.html)

Слово «компонент» встречается и в некоторых других терминах:

- [асинхронный компонент](#async-component)
- [динамический компонент](#dynamic-component)
- [функциональный компонент](#functional-component)
- [веб-компонент](#web-component)

## композабл {#composable}

Термин _композабл_ (_composable_) описывает общий шаблон использования во Vue. Это не отдельная функция Vue, это просто способ использования [Composition API](#composition-api) фреймворка.

- Композабл — это функция.
- Составные части используются для инкапсуляции и повторного использования логики с состоянием.
- Имя функции обычно начинается с `use`, чтобы другие разработчики знали, что это композабл.
- Обычно предполагается, что эта функция будет вызываться во время синхронного выполнения функции `setup()` компонента (или, эквивалентно, во время выполнения блока `<script setup>`). Это привязывает вызов композабла к текущему контексту компонента, например через вызовы `provide()`, `inject()` или `onMounted()`.
- Обычно составные компоненты возвращают обычный объект, а не реактивный. Этот объект содержит ссылки и функции и, как ожидается, будет деструктурирован в вызывающем коде.

Как и в случае со многими паттернами, могут возникнуть разногласия по поводу того, подходит ли конкретный код под этот ярлык. Не все служебные функции JavaScript являются составными. Если функция не использует Composition API, то она, вероятно, не является композаблом. Если она не ожидает, что будет вызвана во время синхронного выполнения `setup()`, то, вероятно, она не является композаблом. Композаблы специально используются для инкапсуляции логики с состоянием, они не являются просто соглашением об именовании функций.

Подробнее о написании композиций см. в главе [Руководство - Композаблы](/guide/reusability/composables.html).

## Composition API {#composition-api}

_Composition API_ — это набор функций, используемых для написания компонентов и составных частей во Vue.

Этот термин также используется для описания одного из двух основных стилей, используемых для написания компонентов, второй — [Options API](#options-api). Компоненты, написанные с использованием Composition API, используют либо `<script setup>`, либо явную функцию `setup()`.

Более подробную информацию можно найти в [ЧаВо по Composition API](/guide/extras/composition-api-faq).

## пользовательский элемент {#custom-element}

_Пользовательский элемент_ — это функция стандарта [веб-компонентов](#web-component), который реализован в современных веб-браузерах. Это означает возможность использовать пользовательский HTML-элемент в вашей HTML-разметке для включения веб-компонента в эту точку страницы.

Vue имеет встроенную поддержку отрисовки пользовательских элементов и позволяет использовать их непосредственно в шаблонах компонентов Vue.

Пользовательские элементы не следует путать с возможностью включать компоненты Vue в качестве тегов в шаблон другого компонента Vue. Пользовательские элементы используются для создания веб-компонентов, а не компонентов Vue.

Узнать больше:

- [Руководство - Vue и веб-компоненты](/guide/extras/web-components.html)

## директива {#directive}

Термин _директива_ относится к атрибутам шаблона, начинающимся с префикса `v-`, или их эквивалентным сокращённым обозначениям.

Встроенные директивы включают `v-if`, `v-for`, `v-bind`, `v-on` и `v-slot`.

Vue также поддерживает создание пользовательских директив, хотя обычно они используются только в качестве «аварийного люка» для прямого манипулирования узлами DOM. Пользовательские директивы, как правило, не могут быть использованы для воссоздания функциональности встроенных директив.

Узнать больше:

- [Руководство - Синтаксис шаблона - Директивы](/guide/essentials/template-syntax.html#directives)
- [Руководство - Пользовательские директивы](/guide/reusability/custom-directives.html)

## динамический компонент {#dynamic-component}

Термин _динамический компонент_ используется для описания случаев, когда выбор того или иного дочернего компонента для отрисовки должен быть сделан динамически. Обычно для этого используется `<component :is="type">`.

Динамический компонент не является особым типом компонента. Любой компонент может быть использован в качестве динамического компонента. Динамичным является выбор компонента, а не сам компонент.

Узнать больше:

- [Руководство - Основы компонентов - Динамические компоненты](/guide/essentials/component-basics.html#dynamic-components)

## эффект {#effect}

См. [реактивный эффект](#reactive-effect) и [побочный эффект](#side-effect).

## событие {#event}

Использование событий для связи между различными частями программы характерно для многих областей программирования. В Vue этот термин обычно применяется как к событиям собственных HTML-элементов, так и к событиям компонентов Vue. Директива `v-on` используется в шаблонах для прослушивания обоих типов событий.

Узнать больше:

- [Руководство - Обработка событий](/guide/essentials/event-handling.html)
- [Руководство - События компонента](/guide/components/events.html)

## фрагмент {#fragment}

Термин _фрагмент_ относится к специальному типу [VNode](#vnode), который используется в качестве родителя для других VNode, но сам не выводит никаких элементов.

Название происходит от схожего понятия [`DocumentFragment`](https://developer.mozilla.org/ru/docs/Web/API/DocumentFragment) в родном DOM API.

Фрагменты используются для поддержки компонентов с несколькими корневыми узлами. Хотя может показаться, что такие компоненты имеют несколько корней, за кулисами они используют узел фрагмента в качестве единственного корня, как родителя узлов `root`.

Фрагменты также используются компилятором шаблонов как способ обернуть несколько динамических узлов, например те, которые создаются с помощью `v-for` или `v-if`. Это позволяет передавать дополнительные подсказки алгоритму исправления [VDOM](#virtual-dom). Многое из этого обрабатывается внутренними средствами, но одно место, где вы можете столкнуться с этим напрямую, — это использование `key` в теге `<template>` с `v-for`. В этом случае `ключ` добавляется как [prop](#prop) к VNode фрагмента.

В настоящее время узлы фрагментов отображаются в DOM как пустые текстовые узлы, но это уже детали реализации. Вы можете столкнуться с этими текстовыми узлами, если используете `$el` или попытаетесь пройтись по DOM с помощью встроенных API браузера.

## функциональный компонент {#functional-component}

Определение компонента обычно представляет собой объект, содержащий опции. Если вы используете `<script setup>`, это может показаться не так, но компонент, экспортированный из файла `.vue`, всё равно будет объектом.

_Функциональный компонент_ — это альтернативная форма компонента, который объявляется с помощью функции. Эта функция действует как [рендер-функция](#render-function) для компонента.

Функциональный компонент не может иметь собственного состояния. Он также не проходит через обычный жизненный цикл компонента, поэтому хуки жизненного цикла не могут быть использованы. Это делает их немного легче, чем обычные компоненты с состоянием.

Узнать больше:

- [Руководство - Рендер-функции и JSX - Функциональные компоненты](/guide/extras/render-function.html#functional-components)

## поднятие {#hoisting}

Термин _поднятие_ используется для описания поведения, при котором функцию или переменную можно использовать до объявления.

JavaScript использует поднятие для некоторых конструкций, таких как `var`, `import` и объявления функций.

В контексте Vue компилятор шаблонов применяет _статическое поднятие_ для повышения производительности. При преобразовании шаблона в рендер-функцию виртуальные узлы (VNodes), соответствующие статическому содержимому, могут быть созданы один раз и затем использованы повторно. Эти статические узлы называются поднятыми, потому что они создаются вне рендер-функции, до её запуска. Аналогичная форма поднятия применяется к статическим объектам или массивам, которые генерируются компилятором шаблонов.

Узнать больше:

- [Руководство - Механизм отрисовки - Статическое поднятие](/guide/extras/rendering-mechanism.html#static-hoisting)

## шаблон в DOM {#in-dom-template}

Существуют различные способы задать шаблон для компонента. В большинстве случаев шаблон предоставляется в виде строки.

Термин _шаблон в DOM_ относится к сценарию, в котором шаблон предоставляется в виде DOM-узлов, а не в виде строки. Затем Vue преобразует узлы DOM в строку шаблона с помощью `innerHTML`.

Как правило, шаблон в DOM начинается как HTML-разметка, написанная непосредственно в HTML страницы. Затем браузер разбирает это на узлы DOM, которые Vue использует для чтения `innerHTML`.

Узнать больше:

- [Руководство - Создание приложения - Шаблон корневого компонента в DOM](/guide/essentials/application.html#in-dom-root-component-template)
- [Руководство - Основы компонентов - Предостережения по разбору шаблонов в DOM](/guide/essentials/component-basics.html#in-dom-template-parsing-caveats)
- [Options: Отрисовка - template](/api/options-rendering.html#template)

## inject {#inject}

Смотрите [provide / inject](#provide-inject).

## хуки жизненного цикла {#lifecycle-hooks}

Экземпляр компонента Vue проходит определённый жизненный цикл. Например, он создается, монтируется, обновляется и размонтируется.

_Хуки жизненного цикла_ — это способ прослушивания этих событий жизненного цикла.

С помощью API Options каждый хук предоставляется как отдельная опция, например `mounted`. В API Composition вместо этого используются функции, такие как `onMounted()`.

Узнать больше:

- [Руководство - Хуки жизненного цикла](/guide/essentials/lifecycle.html)

## макрос {#macro}

Смотрите [макрос компилятора](#compiler-macro).

## именованный слот {#named-slot}

Компонент может иметь несколько слотов, различающихся по имени. Слоты, отличные от слота по умолчанию, называются _именованными слотами_.

Узнать больше:

- [Руководство - Слоты - Именованные слоты](/guide/components/slots.html#named-slots)

## Options API {#options-api}

Компоненты Vue определяются с помощью объектов. Свойства этих компонентных объектов называются _опциями_.

Компоненты могут быть написаны в двух стилях. Один из стилей использует [Composition API](#composition-api) в сочетании с `setup` (либо через опцию `setup()`, либо через `<script setup>`). Другой стиль практически не использует API Composition, вместо этого он использует различные опции компонентов для достижения аналогичного результата. Опции компонента, которые используются таким образом, называются _Options API_.

API Options включает такие опции, как `data()`, `computed`, `methods` и `created()`.

Некоторые опции, такие как `props`, `emits` и `inheritAttrs`, могут быть использованы при создании компонентов с любым из API. Поскольку они являются опциями компонента, их можно считать частью API Options. Однако, поскольку эти параметры также используются в сочетании с `setup()`, обычно полезнее считать их общими для двух стилей компонентов.

Сама функция `setup()` является опцией компонента, поэтому её _можно_ описать как часть API Options. Однако термин «API Options» обычно используется не так. Вместо этого функция `setup()` рассматривается как часть Composition API.

## плагин {#plugin}

Хотя термин _плагин_ может использоваться в самых разных контекстах, во Vue есть особое понятие плагина как способа добавить функциональность в приложение.

Плагины добавляются в приложение с помощью вызова `app.use(plugin)`. Сам плагин — это либо функция, либо объект с функцией `install`. Этой функции будет передан экземпляр приложения, и она сможет делать всё, что ей нужно.

Узнать больше:

- [Руководство - Плагины](/guide/reusability/plugins.html)

## параметр {#prop}

В Vue есть три основных варианта использования термина _параметр_:

- Параметры компонентов
- Параметры VNode
- Параметры слотов

_Параметры компонента_ это то, что большинство людей считают параметрами. Они явно определяются компонентом с помощью `defineProps()` или опции `props`.

Термин _параметры VNode_ относится к свойствам объекта, переданного в качестве второго аргумента в `h()`. Они могут включать параметры компонента, а также события компонента, события DOM, атрибуты DOM и свойства DOM. Обычно вы сталкиваетесь с параметрами VNode только при работе с рендер-функциями для непосредственного управления VNode.

_Параметры слота_ это свойства, передаваемые слоту с ограниченной областью действия.

Во всех случаях параметры — это свойства, которые передаются из других мест.

Хотя слово _props_ происходит от слова _properties_, в контексте Vue термин _props_ имеет гораздо более конкретное значение. Не стоит использовать его в качестве сокращения свойств.

Узнать больше:

- [Руководство - Параметры](/guide/components/props.html)
- [Руководство - Рендер-функции и JSX](/guide/extras/render-function.html)
- [Руководство - Слоты - Слоты с ограниченной областью действия](/guide/components/slots.html#scoped-slots)

## provide / inject {#provide-inject}

`provide` и `inject` — это форма межкомпонентного взаимодействия.

Когда компонент _предоставляет_ значение, все потомки этого компонента могут использовать `inject` для захвата этого значения. В отличие от props, предоставляющий компонент не знает, какой именно компонент получает значение.

`provide` и `inject` иногда используются, чтобы избежать _сквозной передачи параметров_ (_prop drilling_). Они также могут использоваться как неявный способ связи компонента с содержимым его слота.

`provide` также может использоваться на уровне приложения, делая значение доступным для всех компонентов этого приложения.

Узнать больше:

- [Руководство - provide / inject](/guide/components/provide-inject.html)

## реактивный эффект {#reactive-effect}

_Реактивный эффект_ — это часть системы реактивности Vue. Он относится к процессу отслеживания зависимостей функции и повторного запуска этой функции при изменении значений этих зависимостей.

`watchEffect()` — это самый прямой способ создания эффекта. Различные другие части Vue используют эффекты внутри. Например, обновления отрисовки компонентов, `computed()` и `watch()`.

Vue может отслеживать реактивные зависимости только внутри реактивного эффекта. Если значение свойства считывается вне реактивного эффекта, оно «теряет» реактивность, в том смысле, что Vue не будет знать, что делать, если это свойство впоследствии изменится.

Этот термин происходит от «побочного эффекта». Вызов функции эффекта — это побочный эффект изменения значения свойства.

Узнать больше:

- [Руководство - Реактивность в деталях](/guide/extras/reactivity-in-depth.html)

## реактивность {#reactivity}

В общем случае под _реактивностью_ понимается способность автоматически выполнять действия в ответ на изменение данных. Например, обновление DOM или выполнение сетевого запроса при изменении значения данных.

В контексте Vue реактивность используется для описания набора функций. Эти возможности объединяются в _систему реактивности_, которая раскрывается через [Reactivity API](#reactivity-api).

Существуют различные способы реализации системы реактивности. Например, это можно сделать путём статического анализа кода для определения его зависимостей. Однако Vue не использует такую ​​форму системы реактивности.

Вместо этого система реактивности Vue отслеживает доступ к свойствам во время выполнения. Он делает это, используя как оболочки прокси, так и функции получения/установки свойств.

Узнать больше:

- [Руководство - Основы реактивности](/guide/essentials/reactivity-fundamentals.html)
- [Руководство - Реактивность в деталях](/guide/extras/reactivity-in-depth.html)

## Reactivity API {#reactivity-api}

_Reactivity API_ — это набор основных функций Vue, связанных с [реактивностью](#reactivity). Их можно использовать независимо от компонентов. В него входят такие функции, как `ref()`, `reactive()`, `computed()`, `watch()` и `watchEffect()`.

Reactivity API это подмножество Composition API.

Узнать больше:

- [Reactivity API: Ядро](/api/reactivity-core.html)
- [Reactivity API: Утилиты](/api/reactivity-utilities.html)
- [Reactivity API: Дополнительно](/api/reactivity-advanced.html)

## ref {#ref}

> Эта запись посвящена использованию `ref` для реактивности. Для атрибута `ref`, используемого в шаблонах, смотрите [ссылка на элемент шаблона](#template-ref) вместо этого.

Атрибут `ref` является частью системы реактивности Vue. Он представляет собой объект с одним реактивным свойством, называемым `value`.

Существуют различные типы реактивных ссылок. Например, ссылки могут быть созданы с помощью `ref()`, `shallowRef()`, `computed()` и `customRef()`. Функция `isRef()` может использоваться для проверки того, является ли объект ссылкой, а `isReadonly()` — для проверки того, допускает ли ссылка прямое переназначение своего значения.

Узнать больше:

- [Руководство - Основы реактивности](/guide/essentials/reactivity-fundamentals.html)
- [Reactivity API: Ядро](/api/reactivity-core.html)
- [Reactivity API: Утилиты](/api/reactivity-utilities.html)
- [Reactivity API: Дополнительно](/api/reactivity-advanced.html)

## рендер-функция {#render-function}

_Рендер-функция_ — это часть компонента, которая генерирует VNodes (виртуальные узлы), используемые во время отрисовки. Шаблоны компилируются в рендер-функции.

Узнать больше:

- [Руководство - Рендер-функции и JSX](/guide/extras/render-function.html)

## планировщик {#scheduler}

Планировщик (_scheduler_) — это часть внутреннего устройства Vue, которая контролирует время выполнения [реактивных эффектов](#reactive-effect).

При изменении реактивного состояния Vue не сразу запускает обновления отрисовки. Вместо этого он собирает их вместе с помощью очереди. Это гарантирует, что компонент отрисуется только один раз, даже если в базовые данные будет внесено несколько изменений.

[Наблюдатели](/guide/essentials/watchers.html) также собираются в очередь с помощью очереди планировщика. Наблюдатели с опцией `flush: 'pre'` (по умолчанию) будут запущены до отрисовки компонента, а с `flush: 'post'` — после отрисовки компонента.

Задания в планировщике также используются для выполнения различных других внутренних задач, таких как запуск некоторых [хуков жизненного цикла](#lifecycle-hooks) и обновление [ссылок на шаблоны](#template-ref).

## слот с ограниченной областью действия {#scoped-slot}

Термин _слот с ограниченной областью действия_ используется для обозначения [слота](#slot), который получает [параметры](#prop).

Исторически сложилось так, что Vue проводил гораздо большее различие между слотами с областью действия и без нее. В некоторой степени их можно рассматривать как две отдельные функции, объединенные общим синтаксисом шаблонов.

В Vue 3 API слотов были упрощены, чтобы все слоты вели себя как слоты с ограниченной областью действия. Однако варианты использования слотов с областью действия и без нее часто различаются, поэтому этот термин по-прежнему оказывается полезным для обозначения слотов с параметрами.

Свойства, передаваемые в слот, могут использоваться только в определённой области родительского шаблона, отвечающей за определение содержимого слота. Эта область шаблона ведет себя как область видимости для параметров, отсюда и название «слот с ограниченной областью действия».

Узнать больше:

- [Руководство - Слоты - Слоты с ограниченной областью действия](/guide/components/slots.html#scoped-slots)

## SFC {#sfc}

Смотрите [Однофайловый компонент](#single-file-component).

## побочный эффект {#side-effect}

Термин _побочный эффект_ не относится только к Vue. Он используется для описания операций или функций, которые делают что-то за пределами своей локальной области действия.

Например, в контексте установки свойства `user.name = null` ожидается, что оно изменит значение `user.name`. Если при этом выполняется что-то ещё, например, запускается система реактивности Vue, то это можно назвать побочным эффектом. Отсюда происходит термин [реактивный эффект](#reactive-effect) во Vue.

Когда функция описывается как имеющая побочные эффекты, это означает, что функция выполняет какое-то действие, наблюдаемое вне функции, помимо простого возврата значения. Это может означать, что она обновляет значение в состоянии или запускает сетевой запрос.

Этот термин часто используется при описании отрисовки или вычисляемых свойств. Считается, что отрисовка не имеет побочных эффектов. Аналогично, функция получения вычисляемого свойства не должна иметь побочных эффектов.

## однофайловый компонент {#single-file-component}

Термин _однофайловый компонент_ или SFC относится к формату файла `.vue`, который обычно используется для компонентов Vue.

Смотрите также:

- [Руководство - Однофайловые компоненты](/guide/scaling-up/sfc.html)
- [Спецификация синтаксиса SFC](/api/sfc-spec.html)

## слот {#slot}

Слоты используются для передачи контента дочерним компонентам. В то время как параметры используются для передачи значений данных, слоты используются для передачи более богатого контента, состоящего из элементов HTML и других компонентов Vue.

Узнать больше:

- [Руководство - Слоты](/guide/components/slots.html)

## ссылка на элемент шаблона {#template-ref}

Термин _ссылка на элемент шаблона_ относится к использованию атрибута `ref` на каком-либо элементе в шаблоне. После отрисовки компонента этот атрибут используется для заполнения соответствующего свойства либо HTML-элементом, либо экземпляром компонента, который соответствует тегу в шаблоне.

Если вы используете API Options, то такие ссылки отображаются через свойства объекта `$refs`.

С помощью Composition API ссылки на элементы шаблона заполняют реактивный [ref](#ref) с тем же именем.

Ссылки на элементы шаблона не следует путать с реактивными ссылками в системе реактивности Vue.

Узнать больше:

- [Руководство - Ссылки на элементы шаблона](/guide/essentials/template-refs.html)

## VDOM {#vdom}

Смотрите [Virtual DOM](#virtual-dom).

## Virtual DOM {#virtual-dom}

Термин _Virtual DOM_ (VDOM) не является уникальным для Vue. Это общий подход, используемый несколькими веб-фреймворками для управления обновлениями пользовательского интерфейса.

Браузеры используют дерево узлов для представления текущего состояния страницы. Это дерево и API JavaScript, используемые для взаимодействия с ним, называются _объектной моделью документа_, или _DOM_.

Манипуляции с DOM являются основным узким местом в производительности. Виртуальный DOM предоставляет одну из стратегий для управления этим.

Вместо того чтобы создавать узлы DOM напрямую, компоненты Vue генерируют описание того, какие узлы DOM они хотели бы получить. Эти дескрипторы представляют собой обычные объекты JavaScript, известные как VNodes (виртуальные узлы DOM). Создание узлов VNodes обходится относительно недорого.

Каждый раз, когда компонент перерисовывается, новое дерево VNodes сравнивается с предыдущим деревом VNodes, и все различия затем применяются к реальному DOM. Если ничего не изменилось, то DOM не нужно трогать.

Vue использует гибридный подход, который мы называем [Virtual DOM на основе данных компилятора](/guide/extras/rendering-mechanism.html#compiler-informed-virtual-dom). Компилятор шаблонов Vue способен применять оптимизацию производительности на основе статического анализа шаблона. Вместо того чтобы выполнять полное сравнение старого и нового деревьев VNode компонента во время выполнения, Vue может использовать информацию, извлеченную компилятором, чтобы сократить сравнение только до тех частей дерева, которые действительно могут измениться.

Узнать больше:

- [Руководство - Механизм отрисовки](/guide/extras/rendering-mechanism.html)
- [Руководство - Рендер-функции и JSX](/guide/extras/render-function.html)

## VNode {#vnode}

Узел _VNode_ — это _виртуальный узел DOM_. Их можно создать с помощью функции [`h()`](/api/render-function.html#h).

Дополнительные сведения см. в разделе [Виртуальный DOM](#virtual-dom).

## веб-компонент {#web-component}

Стандарт _веб-компонентов_ — это набор функций, реализованных в современных веб-браузерах.

Компоненты Vue не являются веб-компонентами, но `defineCustomElement()` можно использовать для создания [пользовательского элемента](#custom-element) из компонента Vue. Vue также поддерживает использование пользовательских элементов внутри компонентов Vue.

Узнать больше:

- [Руководство - Vue и веб-компоненты](/guide/extras/web-components.html)
